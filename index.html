<!DOCTYPE html>
<html lang="zh-tw">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        #canvas {
            border: #000 1px dashed;
        }
    </style>
</head>
<body>
    <h1>this is a canvas</h1>
    <canvas id="canvas" width="256" height="256"></canvas>
    <script>
        let cav = document.querySelector("#canvas");
        let ctx = cav.getContext("2d");
        
        const drawCell = (text, x, y, isInitial=false) => {
            ctx.rect(x-25, y-25, 50, 50)
            if(isInitial) {
                ctx.rect(x-25+5, y-25+5, 50-10, 50-10)
            }
            ctx.strokeText(text, x-2.5*text.length, y+2.5, 35)
            ctx.stroke()
        };

        drawCell("50", 155, 155, true);

        const dot = (x, y) => {
            // ctx.reset()
            // ctx.moveTo(x,y);
            // ctx.arc(x, y, 1, 0, 6.28);
            ctx.fillRect(x, y, 2.5, 2.5)
            // ctx.stroke()
        };


        const line = (x, y, x2, y2) => {
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          ctx.closePath();
        };

        const drawAxis = (x, y, length=256) => {
          let WIDTH = length, HEIGHT = length;
          line(-WIDTH, y, WIDTH, y);
          line(x, -HEIGHT, x, HEIGHT);
        };
        const drawOrigin = () => {
          drawAxis(0, 0);
        };

        class _DragManager{
          start = {
            x: 0.,
            y: 0.
          }
          _handlers = {
            dragStart: () => {console.log("drag start")},
            draging: () => {},
            dragEnd: (delta) => {console.log(delta)}
          }
          constructor() {
            document.addEventListener("DOMContentLoaded", () => {
              cav.addEventListener("mousedown", this._dragStart);
            });
          }
          _dragStart = (e) => {
            event.preventDefault();
            cav.addEventListener("mousemove", this._drag);
            cav.addEventListener("mouseup", this._dragEnd);
            
            this.start.x = e.offsetX;
            this.start.y = e.offsetY;

            this._handlers.dragStart(e)
          };
          _drag = (e) => {
            const delta = this.getDelta(e);
            this._handlers.draging(delta);
          }
          _dragEnd = (e) => {
            cav.removeEventListener("mousemove", this._drag);
            cav.removeEventListener("mouseup", this._dragEnd);
            
            const delta = this.getDelta(e);
            // console.log(delta)
            this._handlers.dragEnd(delta);
          }
          getDelta = (e) => {
            return {
              x: e.offsetX - this.start.x,
              y: e.offsetY - this.start.y
            }
          };
          registerDragStartHandler = (f) => {
            this._handlers.dragStart = f
          };
          registerDragingHandler = (f) => {
            this._handlers.draging = f
          };
          registerDragEndHandler = (f) => {
            this._handlers.dragEnd = f
          };
        };

        let DragManager = new _DragManager();

        DragManager.registerDragingHandler(({x, y}) => {
          ctx.clearRect(-256, -256, 512, 512);
          drawAxis(x, y);
        });
        DragManager.registerDragEndHandler((delta) => {
          ctx.restore();
          ctx.translate(delta.x, delta.y);
          ctx.save();
          ctx.clearRect(-256, -256, 512, 512);
          drawOrigin();
        });
        
        class _WheelManager {
          _handlers = {
            onScroll: () => {},
          }
          constructor() {
            document.addEventListener("DOMContentLoaded", () => {
              cav.addEventListener("wheel", this._scroll);
            });
          }
          _scroll = (e) => {
            let delta = e.deltaY;
            this._handlers.onScroll(delta);
          };
          registerOnScrollHandler = (f) => {
            this._handlers.onScroll = f;
          };
        };
        let WheelManager = new _WheelManager();
        
        WheelManager.registerOnScrollHandler(console.info);

        /////////////////////////////////////////////////////////////////
        class _Shape {
          x = 0.
          y = 0.
          w = -1.
          h = -1.
          scale = 1.;
          r = -1.
          font = null;
        };

        class _GrafcetShape extends _Shape {
          isSelected = false;

          draw = () => { };
          move = (x, y) => {
            this.x += x;
            this.y += y;
          };
          select = () => { this.isSelected = true; };

        };

        class State extends _GrafcetShape {
          inInitial = false;
          isActivated = false;
          tag = "";
          action = null;
          grafcet = null;

          constructor(tag, x, y, isInitial=false) {
            super();
            this.tag = tag;
            this.x = x;
            this.y = y;
            this.inInitial = isInitial;

            this.w = 50;
            this.font = "10px sans-serif";
          }
          draw = () => {
            let x = this.grafcet.x + this.x,
                y = this.grafcet.y + this.y;
            console.log("draw the state: ", this.tag);

            let w = this.grafcet.scale * this.w;
            if(this.isSelected) {
              ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
              ctx.fillRect(x-.6*w, y-.6*w, 1.2*w, 1.2*w);
            }
            ctx.fillStyle = "#FFFFFF";
            ctx.strokeStyle = "#000000";
            ctx.fillRect(x-.5*w, y-.5*w, w, w);
            ctx.rect(x-.5*w, y-.5*w, w, w);
            if(this.inInitial) {
              let innerW = w * .8;
              ctx.fillRect(x-.5*innerW, y-.5*innerW, innerW, innerW);
              ctx.rect(x-.5*innerW, y-.5*innerW, innerW, innerW);
            }
            ctx.stroke();

            ctx.strokeText(this.tag, x-(2.5*this.tag.length), y+2.5);
          };
        }

        class Action extends _GrafcetShape {
          tag = "";
          fromState = null;

          constructor(fromState) {
            super();
            this.fromState = fromState;
          }
        };

        class _SubGrafcet extends Action {  // ???
          // pass
        };

        class Condition extends _GrafcetShape {
          fromState = null;
          toState = null;
          conditionHandler = () => 1;

          constructor(fromState, toState, conditionHandler =()=>1) {
            super();
            this.fromState = fromState;
            this.toState = toState;
            this.conditionHandler = conditionHandler;
          }
        };

        class ANDCondition extends Condition {
          fromStates = [];
          toStates = [];
          conditionHandler = () => 1;

          constructor(fromStates, toStates, conditionHandler =()=>1) {
            this.fromStates = fromStates;
            this.toStates = toStates;
            this.conditionHandler = conditionHandler;
          }
        };

        class Grafcet extends _GrafcetShape {
          initialState = null;
          
          states = [];

          draw = () => {
            for(let s of this.states) {
              s.draw();
            }
          };

          addAState = (state) => {
            if(this.states.includes(state)) {
              console.warn("duplicated state");
              return;
            }

            state.grafcet = this;
            if(this.initialState == null) {
              this.initialState = state;
            }
            this.states.push(state);
          };

        };

        ///// test /////
        let g = new Grafcet();
        // g.addAState(new State("00", 0, 0, true));
        let s0 = new State("00", 0, 0, true);
        g.addAState(s0);
        g.move(60, 60);
        g.addAState(new State("01", 0, 100));

        g.states.forEach(s => s.select())
        g.draw();

        // DragManager.registerDragEndHandler((delta) => {
        //   ctx.restore();
        //   ctx.translate(delta.x, delta.y);
        //   ctx.save();
        //   ctx.clearRect(-256, -256, 512, 512);
        //   g.draw();
        // });



    </script>
</body>
</html>